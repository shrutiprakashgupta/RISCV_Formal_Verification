1. input [3:0] id_alu_op_r
Desc: The signal shows which instruction is to be executed.
Assumptions: prop_alu_op_types, prop_val_signed_a, prop_val_signed_b, prop_imm_opr    
Note: As all of the instructions are not supported, for example id_alu_op_r value 4'd15 does not correspond to any instruction, thus this restriction is put on the signal. Also as the immediate and signed operands are supported by specific instructions, thus these combinations are restricted to exist together 

2. input [31:0] id_pc_r
Desc: The PC value input to the execute stage from the stage1
Assumptions: freeze_id_pc_r, jump_id_pc_r, inc_id_pc_r
Note: The pc freezes (or preserves its value) while the stall signal is high, changes with the value in register while the branch instruction is there and increment with 4 in general case. This behaviour is simulated with these assumptions. 

3. input [31:0] id_next_pc_r 
Desc: The signal provides the next pc value which is going to be taken
Assumptions: prop_next_pc_val
Note: The same condition is forced to occur, because even in case of branch, this relation holds 

4. input reg_jump_instr
Desc: Depicts whether the jump instruction has to take the target from a register or not 
Assumption: prop_reg_jump_instr
Note: It should be held high only with the corresponding combinations of alu_op and branch instruction type 

5. Assumptions: prop_branch_ex, prop_load_store_ex, property_load_or_store
Note: All of these assumptions ensure the exclusivity of the instruction types, i.e. not two different types of instructions say branch and load or store can happen at the same time. As the f7 section of the instruction which decides the instruction type is different for all of them thus they are exclusive. 

6. Assumptions: freeze_ 
Note: While the stall signal is held high from the execute stage and the stage1 holds its pc at the same value, the inputs from stage1 should not change. This is thus ensured by the assumptions beginning with the keyword freeze and are applied on each of the inputs. 

7. The branch_taken function simulates the behaviour of the alu stage in case a decision has to be taken in regards with branching. Thus while the output from this function is not set, branch souldn't be taken and this is verified with all of these assertions starting with b**_pass or b**_fail. 

8. While the branch is hit, the pipeline is flushed and a NOP is passed through in order to do this. This is marked by an epoch. The assertions prop_n_epoch_jump ensures that this NOP is passed - the destination register value is used to check this so that it gets set to R0 which is not valid for overwriting. 

9. alu_out function decides the expected output of the alu stage, and then the assertions match it with the alu behaviour from rtl.  
