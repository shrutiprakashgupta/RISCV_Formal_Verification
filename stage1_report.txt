1. input [31:0] irdata_i
Desc: Instruction read from the instruction memory
Assumptions: valid_instr_types, valid_f7_types, valid_btype_instr, valid_ltype_instr, valid_stype_instr, valid_itype1_instr, valid_itype2_instr, valid_rtype_instr 
Note: The instructions can have only specific 32 bit values and thus restricted with these assumptions. 
Assumptions: prop_if_stall  
Note: The instruction should change only when the pc changes and thus when the stall signal is held high and pc doesn't increment or change in general, then the instruction should also be held fixed. 

2. input branch_taken_w
Desc: The signal is passed from the execute stage and is held high when branch instruction is hit, this changes the value of pc to the target value. As it is passed to the stage1, it is then used to decide the next pc value and also triggers a NOP to be passed in the pipeline
Assumptions: prop_br_stall_div, valid_br_taken
Note: Branch instruction passed from the first stage triggers the branch_taken signal on the next cycle.The assumptions make sure that branch_taken goes high only after a branch instruction is passed, and that it remains low while divide instruction is in progress. 

3. input [31:0] jump_addr_w
Desc: The address to which pc needs to jump after a branch instruction is hit 
Note: As this target value is word aligned before pc jumping to it thus it can have any 32 bit value. No restriction on it. 
Moreover, the maximum range to which PC can jump is decided by the size of the offset - which is restricted by the instruction format, so no extra check required. 

4. input ex_stall_w
Desc: The stall signal coming from the execute stage while the division instruction remains in progress. This freezes the pc and thus the next instruction is issued only when the division is complete. 
Assumption: valid_ex_stall_div, valid_ex_stall_n_div
Note: This stall signal should remain low for one cycle and then go high (in case of a divide operation) and remain always low in other cases. This is ensured with these two assumptions. 

5. output [31:0] id_pc_r
Desc: The pc signal is stored version of the signal passed to instruction_memory
Assertion: prop_pc_delay
Note: The pc value passed to the instruction memory is stored and passed to the other stages. The same is verified with this assertion.

6. id_next_pc_r is used as execute stage data output, which is verified to be equal to PC + 4 in case of NPC instruction in the execute stage. 

7. Outputs like - id_rd_index_r, addr_1, addr_2, id_a_signed_r, id_b_signed_r, id_alu_op_r and id_op_imm_r, mem_ ,branch_ and jump_ are either direct assignments to slices or internal signals which are not restricted by the RISC V specifications - thus no assertion on them. id_imm_r is assigned the value as per the instruction precedence, this is not being verified with Formal as assertion design will essentially be the same as RTL

8. output [31:0] iaddr_o
Desc: The pc signal passed to the instruction memory
Assertions: pc_inc_prop, pc_jump_prop
Note: The pc should increment by 4, unless a branch instruction is there or stall is set high from the execute stage because a divide instruction is in progress. While, in case of branch instruction it should change to the value passed as the branch target. 

Note - 
1. Jump offset can only be in range +-1MiB - JAL
Jump offset can only be in range of 12-bits for JALR
2. Jump and link should check if the correct PC value is being saved or not 
3. Instead of the misaligned exception, here the last two bits are forced to zero - which is not the case as per the original ISA
4. Need to check if proper value of PC + 4 is being written in case of JUMP Statement - This is already tested in the next stage tb as the next_pc signal is always having the value of pc + 4
